#include "DXFMath.h"

int DXFSearchMonotoneArray(const double* array, int length, double t)
{
	int
		i, i0, i1;

	length--;

	/* Since t is frequently near the ends and bisection takes the
	* longest near the ends, trap those cases here.
	*/
	if (t < array[0])
		return -1;
	if (t >= array[length])
		return (t > array[length]) ? length + 1 : length;
	if (t < array[1])
		return 0;
	if (t >= array[length - 1])
		return (length - 1);


	i0 = 0;
	i1 = length;
	while (array[i0] == array[i0 + 1]) i0++;
	while (array[i1] == array[i1 - 1]) i1--;
	/* From now on we have
	*  1.) array[i0] <= t < array[i1]
	*  2.) i0 <= i < i1.
	* When i0+1 == i1, we have array[i0] <= t < array[i0+1]
	* and i0 is the answer we seek.
	*/
	while (i0 + 1 < i1) {
		i = (i0 + i1) >> 1;
		if (t < array[i]) {
			i1 = i;
			while (array[i1] == array[i1 - 1]) i1--;
		}
		else {
			i0 = i;
			while (array[i0] == array[i0 + 1]) i0++;
		}
	}

	return i0;
}


double
DXFBinomialCoefficient(int i, int j)
{
#define MAX_HALF_N 26
	static const double bc[((MAX_HALF_N - 2)*(MAX_HALF_N - 1)) / 2 + MAX_HALF_N - 2] =
	{ 15.0, 20.0, 28.0, 56.0, 70.0, 45.0, 120.0, 210.0, 252.0, 66.0,
	220.0, 495.0, 792.0, 924.0, 91.0, 364.0, 1001.0, 2002.0, 3003.0,
	3432.0, 120.0, 560.0, 1820.0, 4368.0, 8008.0, 11440.0, 12870.0,
	153.0, 816.0, 3060.0, 8568.0, 18564.0, 31824.0, 43758.0, 48620.0,
	190.0, 1140.0, 4845.0, 15504.0, 38760.0, 77520.0, 125970.0,
	167960.0, 184756.0, 231.0, 1540.0, 7315.0, 26334.0, 74613.0,
	170544.0, 319770.0, 497420.0, 646646.0, 705432.0, 276.0, 2024.0,
	10626.0, 42504.0, 134596.0, 346104.0, 735471.0, 1307504.0,
	1961256.0, 2496144.0, 2704156.0, 325.0, 2600.0, 14950.0, 65780.0,
	230230.0, 657800.0, 1562275.0, 3124550.0, 5311735.0, 7726160.0,
	9657700.0, 10400600.0, 378.0, 3276.0, 20475.0, 98280.0, 376740.0,
	1184040.0, 3108105.0, 6906900.0, 13123110.0, 21474180.0,
	30421755.0, 37442160.0, 40116600.0, 435.0, 4060.0, 27405.0,
	142506.0, 593775.0, 2035800.0, 5852925.0, 14307150.0, 30045015.0,
	54627300.0, 86493225.0, 119759850.0, 145422675.0, 155117520.0,
	496.0, 4960.0, 35960.0, 201376.0, 906192.0, 3365856.0,
	10518300.0, 28048800.0, 64512240.0, 129024480.0, 225792840.0,
	347373600.0, 471435600.0, 565722720.0, 601080390.0, 561.0,
	5984.0, 46376.0, 278256.0, 1344904.0, 5379616.0, 18156204.0,
	52451256.0, 131128140.0, 286097760.0, 548354040.0, 927983760.0,
	1391975640.0, 1855967520.0, 2203961430.0, 2333606220.0, 630.0,
	7140.0, 58905.0, 376992.0, 1947792.0, 8347680.0, 30260340.0,
	94143280.0, 254186856.0, 600805296.0, 1251677700.0, 2310789600.0,
	3796297200.0, 5567902560.0, 7307872110.0, 8597496600.0,
	9075135300.0, 703.0, 8436.0, 73815.0, 501942.0, 2760681.0,
	12620256.0, 48903492.0, 163011640.0, 472733756.0, 1203322288.0,
	2707475148.0, 5414950296.0, 9669554100.0, 15471286560.0,
	22239974430.0, 28781143380.0, 33578000610.0, 35345263800.0,
	780.0, 9880.0, 91390.0, 658008.0, 3838380.0, 18643560.0,
	76904685.0, 273438880.0, 847660528.0, 2311801440.0, 5586853480.0,
	12033222880.0, 23206929840.0, 40225345056.0, 62852101650.0,
	88732378800.0, 113380261800.0, 131282408400.0, 137846528820.0,
	861.0, 11480.0, 111930.0, 850668.0, 5245786.0, 26978328.0,
	118030185.0, 445891810.0, 1471442973.0, 4280561376.0,
	11058116888.0, 25518731280.0, 52860229080.0, 98672427616.0,
	166509721602.0, 254661927156.0, 353697121050.0, 446775310800.0,
	513791607420.0, 538257874440.0, 946.0, 13244.0, 135751.0,
	1086008.0, 7059052.0, 38320568.0, 177232627.0, 708930508.0,
	2481256778.0, 7669339132.0, 21090682613.0, 51915526432.0,
	114955808528.0, 229911617056.0, 416714805914.0, 686353797976.0,
	1029530696964.0, 1408831480056.0, 1761039350070.0,
	2012616400080.0, 2104098963720.0, 1035.0, 15180.0, 163185.0,
	1370754.0, 9366819.0, 53524680.0, 260932815.0, 1101716330.0,
	4076350421.0, 13340783196.0, 38910617655.0, 101766230790.0,
	239877544005.0, 511738760544.0, 991493848554.0, 1749695026860.0,
	2818953098830.0, 4154246671960.0, 5608233007146.0,
	6943526580276.0, 7890371113950.0, 8233430727600.0, 1128.0,
	17296.0, 194580.0, 1712304.0, 12271512.0, 73629072.0,
	377348994.0, 1677106640.0, 6540715896.0, 22595200368.0,
	69668534468.0, 192928249296.0, 482320623240.0, 1093260079344.0,
	2254848913647.0, 4244421484512.0, 7309837001104.0,
	11541847896480.0, 16735679449896.0, 22314239266528.0,
	27385657281648.0, 30957699535776.0, 32247603683100.0, 1225.0,
	19600.0, 230300.0, 2118760.0, 15890700.0, 99884400.0,
	536878650.0, 2505433700.0, 10272278170.0, 37353738800.0,
	121399651100.0, 354860518600.0, 937845656300.0, 2250829575120.0,
	4923689695575.0, 9847379391150.0, 18053528883775.0,
	30405943383200.0, 47129212243960.0, 67327446062800.0,
	88749815264600.0, 108043253365600.0, 121548660036300.0,
	126410606437752.0, 1326.0, 22100.0, 270725.0, 2598960.0,
	20358520.0, 133784560.0, 752538150.0, 3679075400.0,
	15820024220.0, 60403728840.0, 206379406870.0, 635013559600.0,
	1768966344600.0, 4481381406320.0, 10363194502115.0,
	21945588357420.0, 42671977361650.0, 76360380541900.0,
	125994627894135.0, 191991813933920.0, 270533919634160.0,
	352870329957600.0, 426384982032100.0, 477551179875952.0,
	495918532948104.0 };

	int n, half_n, bc_i;

	if (i  < 0 || j  < 0) return  0.0;
	if (0 == i || 0 == j) return  1.0;
	n = i + j;
	if (1 == i || 1 == j) return (double)n;
	if (4 == n)           return  6.0;
	if (5 == n)           return 10.0;

	if (n % 2)
		return DXFBinomialCoefficient(i - 1, j) + DXFBinomialCoefficient(i, j - 1);

	half_n = n >> 1;
	if (half_n > MAX_HALF_N)
		return DXFBinomialCoefficient(i - 1, j) + DXFBinomialCoefficient(i, j - 1);
	if (i > half_n)
		i = n - i;
	/* at this point we have n even,
	* MAX_HALF_N*2 >= n >= 6 and 1 < i <= n/2
	* and we grab the answer from the bc[] table.
	*/
	half_n -= 2;
	bc_i = ((half_n*(half_n + 1)) >> 1) + i - 3;
	return bc[bc_i];

#undef MAX_HALF_N
}

bool DXFEvaluateQuotientRule(int dim, int der_count, int v_stride, double *v)
{
	/*
	The quotient rule says the n-th derivative is

	(n)       (n)          (n)             (n-1)    (1)              (1)    (n-1)
	f  (t) =  x   (t)  -  (w  (t)*f(t) + n*w    (t)*f  (t) + ... + n*w  (t)*f    (t))
	---------------------------------------------------------------------
	w(t)
	*/

	double
		wt, w2, *f, *x, *w;
	int
		i, j, n, df;

	wt = v[dim];
	if (wt == 0.0)
		return false;
	wt = 1.0 / wt;
	i = (der_count + 1)*v_stride;
	x = v;
	while (i--) *x++ *= wt;

	if (der_count) {
		// 1rst derivative - faster special case 
		f = v;            // f = func(t)
		x = v + v_stride; // x = numerator'(t)/w
		wt = -x[dim];     // wt = -denominator'(t)/w
		j = dim; while (j--) *x++ += wt* *f++;
		if (der_count> 1) {
			// 2nd derivative - faster special case 
			f = v + v_stride;
			x = f + v_stride;
			// v = func(t), f = func'(t), x = numerator''(t)/w, 
			// * wt = -2*denominator'(t)/w, w2 = denominator''(t)/w
			wt *= 2.0;
			w2 = -x[dim];
			j = dim; while (j--) *x++ += w2* *v++ + wt* *f++;
			if (der_count>2) {
				df = v_stride - dim;
				// higher derivatives use slower loop
				v -= dim;
				x = v + v_stride * 2;
				for (n = 3; n <= der_count; n++) {
					// computing n-th derivative
					f = v;
					x += v_stride; // x = numerator^(n)/weight 
					w = v + n*v_stride + dim;
					for (i = 0; i < n; i++) {
						// f = value of i-th derivative 
						// w = ((n-i)-th derivative of denominator)/weight
						wt = -DXFBinomialCoefficient(n - i, i) * *w;
						w -= v_stride;
						j = dim; while (j--) *x++ += *f++ * wt;
						x -= dim;
						f += df;
					}
				}
			}
		}
	}

	return true;
}


double DXF_Max(double a, double b){
	return (a<b) ? b : a;
}


float DXF_Max(float a, float b){
	return (a<b) ? b : a;
}


int DXF_Max(int a, int b){
	return (a<b) ? b : a;
}


double DXF_Min(double a, double b){
	return (a<b) ? a : b;
}


float DXF_Min(float a, float b){
	return (a<b) ? a : b;
}


int DXF_Min(int a, int b){
	return (a<b) ? a : b;
}
