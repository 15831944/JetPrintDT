#include "cvShowVideo.h"
#include "DeviceCamera.h"
typedef unsigned char uint8_t;

CCVShowVideo::CCVShowVideo(){
    m_iImageHeight = 600;
    m_iImageWidth = 800;
	m_iXOffset = 0;
	m_iYOffset = 0;
	m_lpBmi = nullptr;
	m_bShowScale = false;
	fRatio = 1.0;
	m_pOverlayImage = nullptr;
}

CCVShowVideo::~CCVShowVideo(){
	m_CurrentImage.Destroy();
}

void CCVShowVideo::SetImageHeight(int iHeight){
    m_iImageHeight = iHeight;
}

void CCVShowVideo::SetImageWidth(int iWidth){
    m_iImageWidth = iWidth;
}


void CCVShowVideo::ScrollImage(int icx, int icy){
	m_iXOffset = icx;
	m_iYOffset = icy;
}

IplImage* CCVShowVideo::RotateImage(IplImage &image, int degree){
	double angle = degree  * CV_PI / 180.;
	double a = sin(angle), b = cos(angle);
	int width = image.width, height = image.height;
	//旋转后的新图尺寸  
	int width_rotate = int(height * fabs(a) + width * fabs(b));
	int height_rotate = int(width * fabs(a) + height * fabs(b));
	IplImage* img_rotate = cvCreateImage(cvSize(width_rotate, height_rotate), image.depth, image.nChannels);
	cvZero(img_rotate);
	//保证原图可以任意角度旋转的最小尺寸  
	int tempLength = sqrt((double)width * width + (double)height *height) + 10;
	int tempX = (tempLength + 1) / 2 - width / 2;
	int tempY = (tempLength + 1) / 2 - height / 2;
	IplImage* temp = cvCreateImage(cvSize(tempLength, tempLength), image.depth, image.nChannels);
	cvZero(temp);
	//将原图复制到临时图像tmp中心  
	cvSetImageROI(temp, cvRect(tempX, tempY, width, height));
	cvCopy(&image, temp, NULL);
	cvResetImageROI(temp);
	//旋转数组map  
	// [ m0  m1  m2 ] ===>  [ A11  A12   b1 ]  
	// [ m3  m4  m5 ] ===>  [ A21  A22   b2 ]  
	float m[6];
	int w = temp->width;
	int h = temp->height;
	m[0] = b;
	m[1] = a;
	m[3] = -m[1];
	m[4] = m[0];
	// 将旋转中心移至图像中间    
	m[2] = w * 0.5f;
	m[5] = h * 0.5f;
	CvMat M = cvMat(2, 3, CV_32F, m);
	cvGetQuadrangleSubPix(temp, img_rotate, &M);
	cvReleaseImage(&temp);

	return img_rotate;
}

void CCVShowVideo::InitializeImage(char * pBuffer){
    if (nullptr == pBuffer)
        return;

	Mat imageMat = Mat(m_iImageHeight, m_iImageWidth, CV_8UC3, (uint8_t*)(pBuffer));
	Mat resizeMat;

	resize(imageMat, resizeMat, cv::Size(m_iImageWidth*fRatio, m_iImageHeight*fRatio));
	Mat transposeMat;
    //
	
	IplImage image = resizeMat;
	CDeviceCamera *pCamera = CDeviceCamera::Instance();
	if (m_bShowScale){
		if (pCamera){

			if (pCamera->m_CurrentCameraType == WATCH_CAMERA){
				//pRotateImage = m_CurrentImage.InitializeWatchOverlayByAddImage(pRotateImage);
				//m_CurrentImage.InitializeWatchOverlay();
				m_CurrentImage.InitializeWatchOverlay(image);
			}

			if (pCamera->m_CurrentCameraType == LOCATE_CAMERA)
				m_CurrentImage.InitializeLocateOverlay(image);
		}
	}

	if (pCamera){
		if (pCamera->m_CurrentCameraType == WATCH_CAMERA){
			//rotate image
			//pRotateImage = RotateImage(image, 270);
			//m_CurrentImage.RotateImage(270, true);
		
			Mat tempMat = cv::Mat(&image);
			cv::transpose(tempMat, transposeMat);
			image = transposeMat;
			
		}
	}

	m_CurrentImage.CopyOf(&image);
}


RGBQUAD VgaDefPal[256] = {
	{ 0x00, 0x00, 0x00, 0x00 }, { 0xa8, 0x00, 0x00, 0x00 }, { 0x00, 0xa8, 0x00, 0x00 }, { 0xa8, 0xa8, 0x00, 0x00 },
	{ 0x00, 0x00, 0xa8, 0x00 }, { 0xa8, 0x00, 0xa8, 0x00 }, { 0x00, 0x54, 0xa8, 0x00 }, { 0xa8, 0xa8, 0xa8, 0x00 },
	{ 0x54, 0x54, 0x54, 0x00 }, { 0xfc, 0x54, 0x54, 0x00 }, { 0x54, 0xfc, 0x54, 0x00 }, { 0xfc, 0xfc, 0x54, 0x00 },
	{ 0x54, 0x54, 0xfc, 0x00 }, { 0xfc, 0x54, 0xfc, 0x00 }, { 0x54, 0xfc, 0xfc, 0x00 }, { 0xfc, 0xfc, 0xfc, 0x00 },
	{ 0x00, 0x00, 0x00, 0x00 }, { 0x14, 0x14, 0x14, 0x00 }, { 0x20, 0x20, 0x20, 0x00 }, { 0x2c, 0x2c, 0x2c, 0x00 },
	{ 0x38, 0x38, 0x38, 0x00 }, { 0x44, 0x44, 0x44, 0x00 }, { 0x50, 0x50, 0x50, 0x00 }, { 0x60, 0x60, 0x60, 0x00 },
	{ 0x70, 0x70, 0x70, 0x00 }, { 0x80, 0x80, 0x80, 0x00 }, { 0x90, 0x90, 0x90, 0x00 }, { 0xa0, 0xa0, 0xa0, 0x00 },
	{ 0xb4, 0xb4, 0xb4, 0x00 }, { 0xc8, 0xc8, 0xc8, 0x00 }, { 0xe0, 0xe0, 0xe0, 0x00 }, { 0xfc, 0xfc, 0xfc, 0x00 },
	{ 0xfc, 0x00, 0x00, 0x00 }, { 0xfc, 0x00, 0x40, 0x00 }, { 0xfc, 0x00, 0x7c, 0x00 }, { 0xfc, 0x00, 0xbc, 0x00 },
	{ 0xfc, 0x00, 0xfc, 0x00 }, { 0xbc, 0x00, 0xfc, 0x00 }, { 0x7c, 0x00, 0xfc, 0x00 }, { 0x40, 0x00, 0xfc, 0x00 },
	{ 0x00, 0x00, 0xfc, 0x00 }, { 0x00, 0x40, 0xfc, 0x00 }, { 0x00, 0x7c, 0xfc, 0x00 }, { 0x00, 0xbc, 0xfc, 0x00 },
	{ 0x00, 0xfc, 0xfc, 0x00 }, { 0x00, 0xfc, 0xbc, 0x00 }, { 0x00, 0xfc, 0x7c, 0x00 }, { 0x00, 0xfc, 0x40, 0x00 },
	{ 0x00, 0xfc, 0x00, 0x00 }, { 0x40, 0xfc, 0x00, 0x00 }, { 0x7c, 0xfc, 0x00, 0x00 }, { 0xbc, 0xfc, 0x00, 0x00 },
	{ 0xfc, 0xfc, 0x00, 0x00 }, { 0xfc, 0xbc, 0x00, 0x00 }, { 0xfc, 0x7c, 0x00, 0x00 }, { 0xfc, 0x40, 0x00, 0x00 },
	{ 0xfc, 0x7c, 0x7c, 0x00 }, { 0xfc, 0x7c, 0x9c, 0x00 }, { 0xfc, 0x7c, 0xbc, 0x00 }, { 0xfc, 0x7c, 0xdc, 0x00 },
	{ 0xfc, 0x7c, 0xfc, 0x00 }, { 0xdc, 0x7c, 0xfc, 0x00 }, { 0xbc, 0x7c, 0xfc, 0x00 }, { 0x9c, 0x7c, 0xfc, 0x00 },
	{ 0x7c, 0x7c, 0xfc, 0x00 }, { 0x7c, 0x9c, 0xfc, 0x00 }, { 0x7c, 0xbc, 0xfc, 0x00 }, { 0x7c, 0xdc, 0xfc, 0x00 },
	{ 0x7c, 0xfc, 0xfc, 0x00 }, { 0x7c, 0xfc, 0xdc, 0x00 }, { 0x7c, 0xfc, 0xbc, 0x00 }, { 0x7c, 0xfc, 0x9c, 0x00 },
	{ 0x7c, 0xfc, 0x7c, 0x00 }, { 0x9c, 0xfc, 0x7c, 0x00 }, { 0xbc, 0xfc, 0x7c, 0x00 }, { 0xdc, 0xfc, 0x7c, 0x00 },
	{ 0xfc, 0xfc, 0x7c, 0x00 }, { 0xfc, 0xdc, 0x7c, 0x00 }, { 0xfc, 0xbc, 0x7c, 0x00 }, { 0xfc, 0x9c, 0x7c, 0x00 },
	{ 0xfc, 0xb4, 0xb4, 0x00 }, { 0xfc, 0xb4, 0xc4, 0x00 }, { 0xfc, 0xb4, 0xd8, 0x00 }, { 0xfc, 0xb4, 0xe8, 0x00 },
	{ 0xfc, 0xb4, 0xfc, 0x00 }, { 0xe8, 0xb4, 0xfc, 0x00 }, { 0xd8, 0xb4, 0xfc, 0x00 }, { 0xc4, 0xb4, 0xfc, 0x00 },
	{ 0xb4, 0xb4, 0xfc, 0x00 }, { 0xb4, 0xc4, 0xfc, 0x00 }, { 0xb4, 0xd8, 0xfc, 0x00 }, { 0xb4, 0xe8, 0xfc, 0x00 },
	{ 0xb4, 0xfc, 0xfc, 0x00 }, { 0xb4, 0xfc, 0xe8, 0x00 }, { 0xb4, 0xfc, 0xd8, 0x00 }, { 0xb4, 0xfc, 0xc4, 0x00 },
	{ 0xb4, 0xfc, 0xb4, 0x00 }, { 0xc4, 0xfc, 0xb4, 0x00 }, { 0xd8, 0xfc, 0xb4, 0x00 }, { 0xe8, 0xfc, 0xb4, 0x00 },
	{ 0xfc, 0xfc, 0xb4, 0x00 }, { 0xfc, 0xe8, 0xb4, 0x00 }, { 0xfc, 0xd8, 0xb4, 0x00 }, { 0xfc, 0xc4, 0xb4, 0x00 },
	{ 0x70, 0x00, 0x00, 0x00 }, { 0x70, 0x00, 0x1c, 0x00 }, { 0x70, 0x00, 0x38, 0x00 }, { 0x70, 0x00, 0x54, 0x00 },
	{ 0x70, 0x00, 0x70, 0x00 }, { 0x54, 0x00, 0x70, 0x00 }, { 0x38, 0x00, 0x70, 0x00 }, { 0x1c, 0x00, 0x70, 0x00 },
	{ 0x00, 0x00, 0x70, 0x00 }, { 0x00, 0x1c, 0x70, 0x00 }, { 0x00, 0x38, 0x70, 0x00 }, { 0x00, 0x54, 0x70, 0x00 },
	{ 0x00, 0x70, 0x70, 0x00 }, { 0x00, 0x70, 0x54, 0x00 }, { 0x00, 0x70, 0x38, 0x00 }, { 0x00, 0x70, 0x1c, 0x00 },
	{ 0x00, 0x70, 0x00, 0x00 }, { 0x1c, 0x70, 0x00, 0x00 }, { 0x38, 0x70, 0x00, 0x00 }, { 0x54, 0x70, 0x00, 0x00 },
	{ 0x70, 0x70, 0x00, 0x00 }, { 0x70, 0x54, 0x00, 0x00 }, { 0x70, 0x38, 0x00, 0x00 }, { 0x70, 0x1c, 0x00, 0x00 },
	{ 0x70, 0x38, 0x38, 0x00 }, { 0x70, 0x38, 0x44, 0x00 }, { 0x70, 0x38, 0x54, 0x00 }, { 0x70, 0x38, 0x60, 0x00 },
	{ 0x70, 0x38, 0x70, 0x00 }, { 0x60, 0x38, 0x70, 0x00 }, { 0x54, 0x38, 0x70, 0x00 }, { 0x44, 0x38, 0x70, 0x00 },
	{ 0x38, 0x38, 0x70, 0x00 }, { 0x38, 0x44, 0x70, 0x00 }, { 0x38, 0x54, 0x70, 0x00 }, { 0x38, 0x60, 0x70, 0x00 },
	{ 0x38, 0x70, 0x70, 0x00 }, { 0x38, 0x70, 0x60, 0x00 }, { 0x38, 0x70, 0x54, 0x00 }, { 0x38, 0x70, 0x44, 0x00 },
	{ 0x38, 0x70, 0x38, 0x00 }, { 0x44, 0x70, 0x38, 0x00 }, { 0x54, 0x70, 0x38, 0x00 }, { 0x60, 0x70, 0x38, 0x00 },
	{ 0x70, 0x70, 0x38, 0x00 }, { 0x70, 0x60, 0x38, 0x00 }, { 0x70, 0x54, 0x38, 0x00 }, { 0x70, 0x44, 0x38, 0x00 },
	{ 0x70, 0x50, 0x50, 0x00 }, { 0x70, 0x50, 0x58, 0x00 }, { 0x70, 0x50, 0x60, 0x00 }, { 0x70, 0x50, 0x68, 0x00 },
	{ 0x70, 0x50, 0x70, 0x00 }, { 0x68, 0x50, 0x70, 0x00 }, { 0x60, 0x50, 0x70, 0x00 }, { 0x58, 0x50, 0x70, 0x00 },
	{ 0x50, 0x50, 0x70, 0x00 }, { 0x50, 0x58, 0x70, 0x00 }, { 0x50, 0x60, 0x70, 0x00 }, { 0x50, 0x68, 0x70, 0x00 },
	{ 0x50, 0x70, 0x70, 0x00 }, { 0x50, 0x70, 0x68, 0x00 }, { 0x50, 0x70, 0x60, 0x00 }, { 0x50, 0x70, 0x58, 0x00 },
	{ 0x50, 0x70, 0x50, 0x00 }, { 0x58, 0x70, 0x50, 0x00 }, { 0x60, 0x70, 0x50, 0x00 }, { 0x68, 0x70, 0x50, 0x00 },
	{ 0x70, 0x70, 0x50, 0x00 }, { 0x70, 0x68, 0x50, 0x00 }, { 0x70, 0x60, 0x50, 0x00 }, { 0x70, 0x58, 0x50, 0x00 },
	{ 0x40, 0x00, 0x00, 0x00 }, { 0x40, 0x00, 0x10, 0x00 }, { 0x40, 0x00, 0x20, 0x00 }, { 0x40, 0x00, 0x30, 0x00 },
	{ 0x40, 0x00, 0x40, 0x00 }, { 0x30, 0x00, 0x40, 0x00 }, { 0x20, 0x00, 0x40, 0x00 }, { 0x10, 0x00, 0x40, 0x00 },
	{ 0x00, 0x00, 0x40, 0x00 }, { 0x00, 0x10, 0x40, 0x00 }, { 0x00, 0x20, 0x40, 0x00 }, { 0x00, 0x30, 0x40, 0x00 },
	{ 0x00, 0x40, 0x40, 0x00 }, { 0x00, 0x40, 0x30, 0x00 }, { 0x00, 0x40, 0x20, 0x00 }, { 0x00, 0x40, 0x10, 0x00 },
	{ 0x00, 0x40, 0x00, 0x00 }, { 0x10, 0x40, 0x00, 0x00 }, { 0x20, 0x40, 0x00, 0x00 }, { 0x30, 0x40, 0x00, 0x00 },
	{ 0x40, 0x40, 0x00, 0x00 }, { 0x40, 0x30, 0x00, 0x00 }, { 0x40, 0x20, 0x00, 0x00 }, { 0x40, 0x10, 0x00, 0x00 },
	{ 0x40, 0x20, 0x20, 0x00 }, { 0x40, 0x20, 0x28, 0x00 }, { 0x40, 0x20, 0x30, 0x00 }, { 0x40, 0x20, 0x38, 0x00 },
	{ 0x40, 0x20, 0x40, 0x00 }, { 0x38, 0x20, 0x40, 0x00 }, { 0x30, 0x20, 0x40, 0x00 }, { 0x28, 0x20, 0x40, 0x00 },
	{ 0x20, 0x20, 0x40, 0x00 }, { 0x20, 0x28, 0x40, 0x00 }, { 0x20, 0x30, 0x40, 0x00 }, { 0x20, 0x38, 0x40, 0x00 },
	{ 0x20, 0x40, 0x40, 0x00 }, { 0x20, 0x40, 0x38, 0x00 }, { 0x20, 0x40, 0x30, 0x00 }, { 0x20, 0x40, 0x28, 0x00 },
	{ 0x20, 0x40, 0x20, 0x00 }, { 0x28, 0x40, 0x20, 0x00 }, { 0x30, 0x40, 0x20, 0x00 }, { 0x38, 0x40, 0x20, 0x00 },
	{ 0x40, 0x40, 0x20, 0x00 }, { 0x40, 0x38, 0x20, 0x00 }, { 0x40, 0x30, 0x20, 0x00 }, { 0x40, 0x28, 0x20, 0x00 },
	{ 0x40, 0x2c, 0x2c, 0x00 }, { 0x40, 0x2c, 0x30, 0x00 }, { 0x40, 0x2c, 0x34, 0x00 }, { 0x40, 0x2c, 0x3c, 0x00 },
	{ 0x40, 0x2c, 0x40, 0x00 }, { 0x3c, 0x2c, 0x40, 0x00 }, { 0x34, 0x2c, 0x40, 0x00 }, { 0x30, 0x2c, 0x40, 0x00 },
	{ 0x2c, 0x2c, 0x40, 0x00 }, { 0x2c, 0x30, 0x40, 0x00 }, { 0x2c, 0x34, 0x40, 0x00 }, { 0x2c, 0x3c, 0x40, 0x00 },
	{ 0x2c, 0x40, 0x40, 0x00 }, { 0x2c, 0x40, 0x3c, 0x00 }, { 0x2c, 0x40, 0x34, 0x00 }, { 0x2c, 0x40, 0x30, 0x00 },
	{ 0x2c, 0x40, 0x2c, 0x00 }, { 0x30, 0x40, 0x2c, 0x00 }, { 0x34, 0x40, 0x2c, 0x00 }, { 0x3c, 0x40, 0x2c, 0x00 },
	{ 0x40, 0x40, 0x2c, 0x00 }, { 0x40, 0x3c, 0x2c, 0x00 }, { 0x40, 0x34, 0x2c, 0x00 }, { 0x40, 0x30, 0x2c, 0x00 },
	{ 0xa8, 0xa8, 0xa8, 0x00 }, { 0x54, 0xfc, 0xfc, 0x00 }, { 0xfc, 0x54, 0xfc, 0x00 }, { 0xfc, 0xfc, 0x54, 0x00 },
	{ 0xfc, 0x54, 0x54, 0x00 }, { 0x54, 0xfc, 0x54, 0x00 }, { 0x54, 0x54, 0xfc, 0x00 }, { 0xfc, 0xfc, 0xfc, 0x00 }
};
RGBQUAD  VgaColorTab[256];

LPBITMAPINFO CCVShowVideo::CtreateMapInfo(IplImage* workImg, int flag)
{                                           //  建立位图信息
	BITMAPINFOHEADER BIH = { 40, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0 };
	LPBITMAPINFO lpBmi;
	int      wid, hei, bits, colors, i;

	wid = workImg->width;
	hei = workImg->height;
	bits = workImg->depth*workImg->nChannels;

	if (bits > 8) colors = 0;
	else colors = 1 << bits;

	lpBmi = (LPBITMAPINFO)malloc(40 + 4 * colors);
	BIH.biWidth = wid;
	BIH.biHeight = hei;
	BIH.biBitCount = (BYTE)bits;
	memcpy(lpBmi, &BIH, 40);                  //  复制位图信息头

	if (bits == 8) {                          //  256 色位图
		if (flag == 1) {                      //  设置灰阶调色板
			for (i = 0; i < 256; i++) {
				VgaColorTab[i].rgbRed = VgaColorTab[i].rgbGreen =
					VgaColorTab[i].rgbBlue = (BYTE)i;
			}
			memcpy(lpBmi->bmiColors, VgaColorTab, 1024);
		}
		else if (flag == 2) {                 //  设置默认调色板
			memcpy(lpBmi->bmiColors, VgaDefPal, 1024);
		}
		else if (flag == 3) {                 //  设置自定义调色板
			memcpy(lpBmi->bmiColors, VgaColorTab, 1024);
		}
	}
	return(lpBmi);
}

int  CCVShowVideo::imageType(IplImage* p)
{
	int	 i, j, k, bpl, n, pg[256];
	BYTE *buf;

	k = p->nChannels;
	if (k == 1) {                             //  检查二值图像
		for (i = 0; i < 256; i++) pg[i] = 0;
		buf = (BYTE*)p->imageData;
		bpl = p->widthStep;
		for (i = 0; i < p->height; i++) {
			for (j = 0; j < p->width; j++) pg[buf[j]]++;
			buf += bpl;
		}
		for (i = 0, n = 0; i < 256; i++) {
			if (pg[i]) n++;
		}
		if (n == 2) k = -1;                     //  二值图像
	}
	return(k);
}

int  CCVShowVideo::imageClone(IplImage* pi, IplImage** ppo)  //  复制 IplImage 位图
{
	if (*ppo) {
		cvReleaseImage(ppo);                //  释放原来位图
	}
	(*ppo) = cvCloneImage(pi);              //  复制新位图
	return(1);
}

int  CCVShowVideo::imageReplace(IplImage* pi, IplImage** ppo)  //  位图替换
{
	if (*ppo)
		cvReleaseImage(ppo);                //  释放原来位图
	(*ppo) = pi;                            //  位图换名
	return(1);
}

void CCVShowVideo::InitializeWatchOverlay(){
	char szText[64] = { 0 };

	long imageWidth = m_pOverlayImage->width;
	long imageHeight = m_pOverlayImage->height;

	// Attach the device context.
	int center_x = imageWidth / 2;
	int center_y = imageHeight / 2;

	// Create a blue pen. 
	CvFont font;
	double hscale = 0.3;
	double vscale = 0.3;
	double linewidth = 0.4;
	cvInitFont(&font, CV_FONT_HERSHEY_SIMPLEX | CV_FONT_ITALIC, hscale, vscale, linewidth, 1, CV_AA);
	CvScalar color = cvScalar(0, 0, 255);
	CvPoint posStart = cvPoint(0, 0);
	CvPoint posEnd = cvPoint(0, 0);
	CvPoint textPos = cvPoint(0, 0);

	// Draw a cross in the overlay buffer. 
	posStart = cvPoint(0, imageHeight / 2);
	posEnd = cvPoint(imageWidth, imageHeight / 2);
	cvLine(m_pOverlayImage, posStart, posEnd, color);

	posStart = cvPoint(imageWidth / 2, 0);
	posEnd = cvPoint(imageWidth / 2, imageHeight);
	cvLine(m_pOverlayImage, posStart, posEnd, color);

	for (int i = 1; i <= 30; i++)
	{
		//左侧
		if (0 == (i) % 5)
		{
			posStart = cvPoint(center_x - 10 * i, center_y);
			posEnd = cvPoint(center_x - 10 * i, center_y + 25);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x - 10 * i, center_y);
			posEnd = cvPoint(center_x - 10 * i, center_y - 25);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			if (0 == (i % 2))
			{
				sprintf(szText, "%.2f um", -150.0*(i / 5));
				textPos = cvPoint(center_x - 10 * i, center_y - 25);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}
			else
			{
				sprintf(szText, "%.2f um", -150.0*(i / 5));
				textPos = cvPoint(center_x - 10 * i, center_y + 25);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}

		}
		else
		{
			posStart = cvPoint(center_x - 10 * i, center_y);
			posEnd = cvPoint(center_x - 10 * i, center_y + 15);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x - 10 * i, center_y);
			posEnd = cvPoint(center_x - 10 * i, center_y - 15);
			cvLine(m_pOverlayImage, posStart, posEnd, color);
		}

		//右侧
		if (0 == (i) % 5)
		{
			posStart = cvPoint(center_x + 10 * i, center_y);
			posEnd = cvPoint(center_x + 10 * i, center_y + 25);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x + 10 * i, center_y);
			posEnd = cvPoint(center_x + 10 * i, center_y - 25);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			if (0 == (i % 2))
			{
				sprintf(szText, "%.2f um", 150.0*(i / 5));
				textPos = cvPoint(center_x + 10 * i, center_y - 25);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}
			else
			{
				sprintf(szText, "%.2f um", 150.0*(i / 5));
				textPos = cvPoint(center_x + 10 * i, center_y + 25);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}

		}
		else
		{
			posStart = cvPoint(center_x + 10 * i, center_y);
			posEnd = cvPoint(center_x + 10 * i, center_y + 15);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x + 10 * i, center_y);
			posEnd = cvPoint(center_x + 10 * i, center_y - 15);
			cvLine(m_pOverlayImage, posStart, posEnd, color);
		}
	}

	for (int i = 1; i <= 80; i++)
	{
		//上侧
		if (0 == (i) % 5)
		{
			posStart = cvPoint(center_x, center_y - 4 * i);
			posEnd = cvPoint(center_x + 25, center_y - 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x, center_y - 4 * i);
			posEnd = cvPoint(center_x - 25, center_y - 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			//TextOut
			if (0 == i % 2)
			{
				sprintf(szText, "%.2f um", -60.0*(i / 5));
				textPos = cvPoint(center_x - 55, center_y - 4 * i);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}
			else
			{
				sprintf(szText, "%.2f um", -60.0*(i / 5));
				textPos = cvPoint(center_x + 25, center_y - 4 * i);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}


		}
		else
		{
			posStart = cvPoint(center_x, center_y - 4 * i);
			posEnd = cvPoint(center_x + 15, center_y - 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x, center_y - 4 * i);
			posEnd = cvPoint(center_x - 15, center_y - 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

		}

		//下侧
		if (0 == (i) % 5)
		{
			posStart = cvPoint(center_x, center_y + 4 * i);
			posEnd = cvPoint(center_x + 25, center_y + 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x, center_y + 4 * i);
			posEnd = cvPoint(center_x - 25, center_y + 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			//TextOut
			if (0 == i % 2)
			{
				sprintf(szText, "%.2f um", 60.0*(i / 5));
				textPos = cvPoint(center_x - 55, center_y + 4 * i);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}
			else
			{
				sprintf(szText, "%.2f um", 60.0*(i / 5));
				textPos = cvPoint(center_x + 25, center_y + 4 * i);
				cvPutText(m_pOverlayImage, szText, textPos, &font, color);
			}


		}
		else
		{
			posStart = cvPoint(center_x, center_y + 4 * i);
			posEnd = cvPoint(center_x + 15, center_y + 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);

			posStart = cvPoint(center_x, center_y + 4 * i);
			posEnd = cvPoint(center_x - 15, center_y + 4 * i);
			cvLine(m_pOverlayImage, posStart, posEnd, color);
		}
	}
}